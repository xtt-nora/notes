(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{461:function(e,t,r){e.exports=r.p+"assets/img/img.af67fd4a.png"},462:function(e,t,r){e.exports=r.p+"assets/img/mvc.fe56d805.png"},463:function(e,t,r){e.exports=r.p+"assets/img/mvvm.dd92fd1e.png"},499:function(e,t,r){"use strict";r.r(t);var a=r(2),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("@[TOC]")]),e._v(" "),t("h1",{attrs:{id:"vue知识记录进度条"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue知识记录进度条"}},[e._v("#")]),e._v(" vue知识记录进度条 📄")]),e._v(" "),t("p",[t("strong",[e._v("对vue官方文档以及学习过程的记录数据")])]),e._v(" "),t("h2",{attrs:{id:"基础理念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础理念"}},[e._v("#")]),e._v(" 基础理念")]),e._v(" "),t("h3",{attrs:{id:"vue的基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的基本原理"}},[e._v("#")]),e._v(" Vue的基本原理")]),e._v(" "),t("p",[e._v("当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。")]),e._v(" "),t("h3",{attrs:{id:"双向数据绑定的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定的原理"}},[e._v("#")]),e._v(" 双向数据绑定的原理")]),e._v(" "),t("p",[t("span",{staticStyle:{color:"orangered"}},[e._v("Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),t("br"),e._v("\n主要分为以下几个步骤：\n需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\ncompile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\nWatcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:"),t("br"),e._v("\n①在自身实例化时往属性订阅器(dep)里面添加自己"),t("br"),e._v("\n②自身必须有一个update()方法"),t("br"),e._v("\n③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。"),t("br"),e._v("\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n"),t("img",{attrs:{src:r(461),alt:"这是图片"}})]),e._v(" "),t("h3",{attrs:{id:"使用-object-defineproperty-来进行数据劫持有什么缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-object-defineproperty-来进行数据劫持有什么缺点"}},[e._v("#")]),e._v(" 使用 Object.defineProperty() 来进行数据劫持有什么缺点？")]),e._v(" "),t("p",[e._v("在对一些属性进行操作时，使用这种方法无法拦截，比如"),t("span",{staticStyle:{color:"orangered"}},[e._v("通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。")]),e._v("  更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。")]),e._v(" "),t("p",[e._v("在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。")]),e._v(" "),t("h3",{attrs:{id:"mvvm、mvc的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm、mvc的区别"}},[e._v("#")]),e._v(" MVVM、MVC的区别")]),e._v(" "),t("ol",[t("li",[e._v("MVC"),t("br"),e._v("\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。"),t("br"),e._v("\n其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。"),t("br"),e._v(" "),t("img",{attrs:{src:r(462),alt:"img.png"}})]),e._v(" "),t("li",[e._v("MVVM"),t("br"),e._v("\nMVVM 分为 Model、View、ViewModel：\nModel代表数据模型，数据和业务逻辑都在Model层中定义；"),t("br"),e._v("\nView代表UI视图，负责数据的展示；"),t("br"),e._v("\nViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；"),t("br"),e._v("\nModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。\n"),t("img",{attrs:{src:r(463),alt:"img.png"}})])]),e._v(" "),t("h3",{attrs:{id:"vue模版编译原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue模版编译原理"}},[e._v("#")]),e._v(" Vue模版编译原理")]),e._v(" "),t("p",[e._v("vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。")]),e._v(" "),t("ul",[t("li",[e._v("解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。")]),e._v(" "),t("li",[e._v("优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。")]),e._v(" "),t("li",[e._v("生成阶段：将最终的AST转化为render函数字符串。")])]),e._v(" "),t("h3",{attrs:{id:"data为什么是一个函数而不是对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#data为什么是一个函数而不是对象"}},[e._v("#")]),e._v(" data为什么是一个函数而不是对象")]),e._v(" "),t("p",[e._v("JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。"),t("br"),e._v("\n而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。"),t("br"),e._v("\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。")]),e._v(" "),t("h3",{attrs:{id:"lru-least-recently-used-缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-least-recently-used-缓存策略"}},[e._v("#")]),e._v(" LRU （least recently used）缓存策略")]),e._v(" "),t("p",[e._v('LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 "如果数据最近被访问过，那么将来被访问的几率也更高"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶')]),e._v(" "),t("ul",[t("li",[e._v("新数据插入到链表头部")]),e._v(" "),t("li",[e._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部")]),e._v(" "),t("li",[e._v("链表满的时候，将链表尾部的数据丢弃。")])]),e._v(" "),t("h3",{attrs:{id:"vue的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的优点"}},[e._v("#")]),e._v(" Vue的优点")]),e._v(" "),t("ul",[t("li",[e._v("轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；")]),e._v(" "),t("li",[e._v("简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；")]),e._v(" "),t("li",[e._v("双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；")]),e._v(" "),t("li",[e._v("组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；")]),e._v(" "),t("li",[e._v("视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；")]),e._v(" "),t("li",[e._v("虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；")]),e._v(" "),t("li",[e._v("运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);