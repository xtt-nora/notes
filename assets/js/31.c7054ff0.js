(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{465:function(t,s,a){t.exports=a.p+"assets/img/https.747e1e00.png"},466:function(t,s,a){t.exports=a.p+"assets/img/tls.a3aaff96.png"},467:function(t,s,a){t.exports=a.p+"assets/img/osi.5d165836.png"},468:function(t,s,a){t.exports=a.p+"assets/img/tcp.3bc70d20.png"},469:function(t,s,a){t.exports=a.p+"assets/img/wo.7e22a801.png"},470:function(t,s,a){t.exports=a.p+"assets/img/hui.66d161fa.png"},508:function(t,s,a){"use strict";a.r(s);var v=a(2),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("@[TOC]")]),t._v(" "),s("h1",{attrs:{id:"计算机网络知识记录进度条"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络知识记录进度条"}},[t._v("#")]),t._v(" 计算机网络知识记录进度条 📄")]),t._v(" "),s("h2",{attrs:{id:"http协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" Http协议")]),t._v(" "),s("h3",{attrs:{id:"常见的http请求方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求方法"}},[t._v("#")]),t._v(" 常见的http请求方法")]),t._v(" "),s("ul",[s("li",[t._v("GET: 向服务器获取数据；")]),t._v(" "),s("li",[t._v("POST：将实体提交到指定的资源，通常会造成服务器资源的修改；")]),t._v(" "),s("li",[t._v("PUT：上传文件，更新数据；")]),t._v(" "),s("li",[t._v("DELETE：删除服务器上的对象；")]),t._v(" "),s("li",[t._v("HEAD：获取报文首部，与GET相比，不返回报文主体部分；")]),t._v(" "),s("li",[t._v("OPTIONS：询问支持的请求方法，用来跨域请求；")]),t._v(" "),s("li",[t._v("CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；")]),t._v(" "),s("li",[t._v("TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。"),s("br"),t._v(" "),s("strong",[t._v("OPTIONS请求方法及使用场景")]),t._v("：OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。\nOPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。"),s("strong",[t._v("通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能")]),t._v("。该请求方法的响应不能缓存。\nOPTIONS请求方法的主要用途有两个：")]),t._v(" "),s("li",[t._v("获取服务器支持的所有HTTP请求方法；")]),t._v(" "),s("li",[t._v("用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。")])]),t._v(" "),s("h3",{attrs:{id:"restful风格"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#restful风格"}},[t._v("#")]),t._v(" RESTful风格")]),t._v(" "),s("p",[t._v("从常见的http引申到RESTful API 设计指南！"),s("br"),t._v("\n前端设备层出不穷那么就需要一种统一的机制，方便不同的前端设备与后端进行通信。"),s("br"),t._v(" "),s("strong",[t._v("如何设立一套合理的好用的API呢？")])]),t._v(" "),s("ol",[s("li",[t._v("API与用户的通信协议，总是使用HTTPs协议。")]),t._v(" "),s("li",[t._v("应该尽量将API部署在专用域名之下，或者如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。"),s("code",[t._v("https://api.example.com或者https://example.org/api/")])]),t._v(" "),s("li",[t._v("应该将API的版本号放入URL。"),s("code",[t._v("https://api.example.com/v1/")])]),t._v(" "),s("li",[t._v('在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。'),s("br"),t._v("\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("https://api.example.com/v1/zoos\nhttps://api.example.com/v1/animals\nhttps://api.example.com/v1/employees\n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[t._v("对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）\n"),s("ul",[s("li",[t._v("GET（SELECT）：从服务器取出资源（一项或多项）。")]),t._v(" "),s("li",[t._v("POST（CREATE）：在服务器新建一个资源。")]),t._v(" "),s("li",[t._v("PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。")]),t._v(" "),s("li",[t._v("PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。")]),t._v(" "),s("li",[t._v("DELETE（DELETE）：从服务器删除资源。")])])])]),t._v(" "),s("h3",{attrs:{id:"http1-0-http1-1-http2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-http1-1-http2-0"}},[t._v("#")]),t._v(" Http1.0,Http1.1,Http2.0")]),t._v(" "),s("ol",[s("li",[t._v("Http1.0和Http1.1的区别\n"),s("ul",[s("li",[s("strong",[t._v("http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接")]),t._v("。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延")]),t._v(" "),s("li",[t._v("在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")]),t._v(" "),s("li",[t._v("在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。")]),t._v(" "),s("li",[t._v("http1.1 中新增了 host 字段，用来指定服务器的域名")]),t._v(" "),s("li",[t._v("http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。")])])]),t._v(" "),s("li",[t._v("Http1.1和Http2.0的区别")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("二进制协议")]),t._v('：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。')]),t._v(" "),s("li",[s("strong",[t._v("多路复用")]),t._v('：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。')]),t._v(" "),s("li",[s("strong",[t._v("数据流")]),t._v("：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。")]),t._v(" "),s("li",[s("strong",[t._v("头信息压缩")]),t._v("：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。")]),t._v(" "),s("li",[s("strong",[t._v("服务器推送")]),t._v("： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。\n【1】队头堵塞："),s("br"),t._v("\n队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。"),s("strong",[t._v("队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"http和https协议的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http和https协议的区别"}},[t._v("#")]),t._v(" HTTP和HTTPS协议的区别")]),t._v(" "),s("ol",[s("li",[t._v("HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；")]),t._v(" "),s("li",[t._v("HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；")]),t._v(" "),s("li",[t._v("使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；")]),t._v(" "),s("li",[t._v("HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。")])]),t._v(" "),s("h3",{attrs:{id:"当在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[t._v("#")]),t._v(" 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("解析URL：")]),t._v(" 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。")]),t._v(" "),s("li",[s("strong",[t._v("缓存判断：")]),t._v(" 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。")]),t._v(" "),s("li",[s("strong",[t._v("DNS解析：")]),t._v(" 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。")]),t._v(" "),s("li",[s("strong",[t._v("获取MAC地址：")]),t._v(" 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。")]),t._v(" "),s("li",[s("strong",[t._v("TCP三次握手：")]),t._v(" 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。")]),t._v(" "),s("li",[s("strong",[t._v("HTTPS握手")]),t._v(" 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。")]),t._v(" "),s("li",[s("strong",[t._v("返回数据：")]),t._v(" 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。")]),t._v(" "),s("li",[s("strong",[t._v("页面渲染：")]),t._v(" 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。")]),t._v(" "),s("li",[s("strong",[t._v("TCP四次挥手：")]),t._v(" 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")])]),t._v(" "),s("h3",{attrs:{id:"url有哪些组成部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#url有哪些组成部分"}},[t._v("#")]),t._v(" URL有哪些组成部分")]),t._v(" "),s("p",[t._v("以这个URL为例："),s("code",[t._v("www.aspxfans.com:8080/news/index.…")]),t._v("\n一个完整的URL包括以下几部分：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("协议部分：")]),t._v(' 该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符；')]),t._v(" "),s("li",[s("strong",[t._v("域名部分：")]),t._v(" 该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用")]),t._v(" "),s("li",[s("strong",[t._v("端口部分：")]),t._v(" 跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；")]),t._v(" "),s("li",[s("strong",[t._v("虚拟目录部分：")]),t._v(" 从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；")]),t._v(" "),s("li",[s("strong",[t._v("文件名部分：")]),t._v("  从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；")]),t._v(" "),s("li",[s("strong",[t._v("锚部分：")]),t._v(" 从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；")]),t._v(" "),s("li",[s("strong",[t._v("参数部分：")]),t._v("  从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。")])]),t._v(" "),s("h2",{attrs:{id:"https协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https协议"}},[t._v("#")]),t._v(" Https协议")]),t._v(" "),s("h3",{attrs:{id:"什么是https协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是https协议"}},[t._v("#")]),t._v(" 什么是HTTPS协议？")]),t._v(" "),s("p",[t._v("超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n"),s("img",{attrs:{src:a(465),alt:"img.png"}}),t._v(" "),s("strong",[t._v("HTTP协议采用明文传输")]),t._v("信息，存在"),s("strong",[t._v("信息窃听")]),t._v("、"),s("strong",[t._v("信息篡改")]),t._v("和"),s("strong",[t._v("信息劫持")]),t._v("的风险，而协议TLS/SSL具有"),s("strong",[t._v("身份验证")]),t._v("、"),s("strong",[t._v("信息加密")]),t._v("和"),s("strong",[t._v("完整性校验")]),t._v("的功能，可以避免此类问题发生。"),s("br"),t._v("\n安全层的主要职责就是"),s("strong",[t._v("对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"tls-ssl的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tls-ssl的工作原理"}},[t._v("#")]),t._v(" TLS/SSL的工作原理")]),t._v(" "),s("p",[t._v("TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。")]),t._v(" "),s("p",[t._v("TLS/SSL的功能实现主要依赖三类基本算法："),s("strong",[t._v("散列函数hash、对称加密、非对称加密")]),t._v("。这三类算法的作用如下：")]),t._v(" "),s("ul",[s("li",[t._v("基于散列函数验证信息的完整性")]),t._v(" "),s("li",[t._v("对称加密算法采用协商的秘钥对数据加密")]),t._v(" "),s("li",[t._v("非对称加密实现身份认证和秘钥协商\n"),s("img",{attrs:{src:a(466),alt:"img.png"}})])]),t._v(" "),s("h2",{attrs:{id:"网络模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络模型"}},[t._v("#")]),t._v(" 网络模型")]),t._v(" "),s("h3",{attrs:{id:"osi七层网络模型-你了解吗-具体功能有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#osi七层网络模型-你了解吗-具体功能有哪些"}},[t._v("#")]),t._v(" OSI七层网络模型，你了解吗？具体功能有哪些")]),t._v(" "),s("p",[t._v("ISO为了更好的使网络应用更为普及，推出了OSI参考模型。\n"),s("img",{attrs:{src:a(467),alt:"img.png"}})]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("应用层")]),s("br"),t._v("\nOSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。\n"),s("ul",[s("li",[t._v("在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。")]),t._v(" "),s("li",[t._v("FTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。")]),t._v(" "),s("li",[t._v("SMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。")])])]),t._v(" "),s("li",[s("strong",[t._v("表示层")]),s("br"),t._v("\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n在项目开发中，为了方便数据传输，可以使用"),s("code",[t._v("base64")]),t._v("对数据进行编解码。如果按功能来划分，"),s("em",[t._v("base64应该是工作在表示层")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("会话层")]),s("br"),t._v("\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。")]),t._v(" "),s("li",[s("strong",[t._v("传输层")]),s("br"),t._v("\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。")]),t._v(" "),s("li",[s("strong",[t._v("网络层")]),t._v("\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。")]),t._v(" "),s("li",[s("strong",[t._v("数据链路层")]),s("br"),t._v("\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。")]),t._v(" "),s("li",[s("strong",[t._v("物理层")]),s("br"),t._v("\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\n"),s("strong",[t._v("OSI七层模型通信特点：")]),t._v(" 对等通信 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-ip五层协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip五层协议"}},[t._v("#")]),t._v(" TCP/IP五层协议")]),t._v(" "),s("p",[t._v("TCP/IP五层协议和OSI的七层协议对应关系如下：\n"),s("img",{attrs:{src:a(468),alt:"img.png"}}),t._v("\n从上图中可以看出，TCP/IP模型比OSI模型更加简洁，它把"),s("code",[t._v("应用层/表示层/会话层")]),t._v("全部整合为了"),s("code",[t._v("应用层")]),t._v("。\n在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。")]),t._v(" "),s("h2",{attrs:{id:"三握四挥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三握四挥"}},[t._v("#")]),t._v(" 三握四挥")]),t._v(" "),s("h3",{attrs:{id:"三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),s("p",[s("img",{attrs:{src:a(469),alt:"img.png"}}),t._v("\n一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主"),s("strong",[t._v("要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备")]),t._v("。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。"),s("br"),t._v("\n刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。"),s("br"),t._v("\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。\n首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。"),s("br"),t._v("\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y"),s("br"),t._v("\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。\n确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")]),t._v(" "),s("h3",{attrs:{id:"为什么要三次握手呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三次握手呢"}},[t._v("#")]),t._v(" 为什么要三次握手呢？")]),t._v(" "),s("p",[s("strong",[t._v("那为什么要三次握手呢？两次不行吗？")])]),t._v(" "),s("ul",[s("li",[t._v("为了确认双方的接收能力和发送能力都正常")]),t._v(" "),s("li",[t._v("如果是用两次握手，则会出现下面这种情况：")])]),t._v(" "),s("blockquote",[s("p",[t._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])]),t._v(" "),s("p",[s("strong",[t._v("简单来说就是以下三步：")])]),t._v(" "),s("ul",[s("li",[t._v("第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。")]),t._v(" "),s("li",[t._v("第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。")]),t._v(" "),s("li",[t._v("第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。"),s("br"),t._v("\nTCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。"),s("br"),t._v(" "),s("em",[t._v("三次握手： 拿到的三次数据都不是正式的数据")])])]),t._v(" "),s("h3",{attrs:{id:"四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),s("p",[s("img",{attrs:{src:a(470),alt:"img.png"}}),t._v("\n刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下："),s("br"),t._v("\n第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。")]),t._v(" "),s("blockquote",[s("p",[t._v("即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")])]),t._v(" "),s("p",[t._v("第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。")]),t._v(" "),s("blockquote",[s("p",[t._v("即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")])]),t._v(" "),s("p",[t._v("第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。")]),t._v(" "),s("blockquote",[s("p",[t._v("即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")])]),t._v(" "),s("p",[t._v("第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")]),t._v(" "),s("blockquote",[s("p",[t._v("即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。")])]),t._v(" "),s("h3",{attrs:{id:"为什么需要四次挥手呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要四次挥手呢"}},[t._v("#")]),t._v(" 为什么需要四次挥手呢？")]),t._v(" "),s("p",[t._v("因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。")]),t._v(" "),s("p",[s("strong",[t._v("简单来说就是以下四步：")])]),t._v(" "),s("ul",[s("li",[t._v("第一次挥手： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。")]),t._v(" "),s("li",[t._v("第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。")]),t._v(" "),s("li",[t._v("第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。")]),t._v(" "),s("li",[t._v("第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。"),s("br"),t._v("\nTCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。"),s("br"),t._v("\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。")])]),t._v(" "),s("h2",{attrs:{id:"websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),s("h3",{attrs:{id:"理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[t._v("#")]),t._v(" 理解")]),t._v(" "),s("p",[t._v("WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。"),s("br"),t._v("\nWebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。"),s("br"),t._v("\nWebSocket原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。")]),t._v(" "),s("h3",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("ul",[s("li",[t._v("支持双向通信，实时性更强")]),t._v(" "),s("li",[t._v("可以发送文本，也可以发送二进制数据‘’")]),t._v(" "),s("li",[t._v("建立在TCP协议之上，服务端的实现比较容易")]),t._v(" "),s("li",[t._v("数据格式比较轻量，性能开销小，通信高效")]),t._v(" "),s("li",[t._v("没有同源限制，客户端可以与任意服务器通信")]),t._v(" "),s("li",[t._v("协议标识符是ws（如果加密，则为wss），服务器网址就是 URL")]),t._v(" "),s("li",[t._v("与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。")])]),t._v(" "),s("h3",{attrs:{id:"使用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[t._v("#")]),t._v(" 使用方法")]),t._v(" "),s("p",[t._v("在客户端中")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在index.html中直接写WebSocket，设置服务端的端口号为 9999")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" ws "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WebSocket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ws://localhost:9999'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在客户端与服务端建立连接后触发")]),t._v("\nws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onopen")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Connection open."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    ws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("send")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在服务端给客户端发来消息的时候触发")]),t._v("\nws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onmessage")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 打印的是MessageEvent对象")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 打印的是收到的消息")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在客户端与服务端建立关闭后触发")]),t._v("\nws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onclose")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("evt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Connection closed."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n")])])]),s("h3",{attrs:{id:"即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别"}},[t._v("#")]),t._v(" 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？")]),t._v(" "),s("p",[s("em",[t._v("短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。")]),s("br"),t._v(" "),s("strong",[t._v("短轮询的基本思路：")]),t._v(" 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。"),s("br"),t._v(" "),s("strong",[t._v("长轮询的基本思路：")]),t._v(" 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。"),s("br"),t._v(" "),s("strong",[t._v("SSE 的基本思想：")]),t._v(" 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。"),s("br"),t._v(" "),s("strong",[t._v("WebSocket")]),t._v(" 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。"),s("br"),t._v(" "),s("em",[t._v("上面的四个通信协议，前三个都是基于HTTP协议的。")]),s("br"),t._v("\n对于这四种即使通信协议，从"),s("strong",[t._v("性能的角度")]),t._v("来看： "),s("code",[t._v("WebSocket > 长连接（SEE） > 长轮询 > 短轮询")]),t._v(" 但是，我们如果考虑"),s("strong",[t._v("浏览器的兼容性")]),t._v("问题，顺序就恰恰相反了： "),s("code",[t._v("短轮询 > 长轮询 > 长连接（SEE） > WebSocket")]),t._v("所以，还是要根据具体的使用场景来判断使用哪种方式。")])])}),[],!1,null,null,null);s.default=_.exports}}]);