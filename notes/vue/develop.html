<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>nora的笔记本</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="📝记录学习数据">
    
    <link rel="preload" href="/notes/assets/css/0.styles.29a815fb.css" as="style"><link rel="preload" href="/notes/assets/js/app.a7b0928b.js" as="script"><link rel="preload" href="/notes/assets/js/7.d12e4840.js" as="script"><link rel="preload" href="/notes/assets/js/2.dfe3d436.js" as="script"><link rel="preload" href="/notes/assets/js/1.102225a7.js" as="script"><link rel="preload" href="/notes/assets/js/24.44ecaef9.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.d7e10e54.js"><link rel="prefetch" href="/notes/assets/js/11.9d67d3b8.js"><link rel="prefetch" href="/notes/assets/js/14.cdb8310d.js"><link rel="prefetch" href="/notes/assets/js/15.eb4690e5.js"><link rel="prefetch" href="/notes/assets/js/16.ac6caa6f.js"><link rel="prefetch" href="/notes/assets/js/17.2c9e2528.js"><link rel="prefetch" href="/notes/assets/js/18.1ccfa51e.js"><link rel="prefetch" href="/notes/assets/js/19.4e924347.js"><link rel="prefetch" href="/notes/assets/js/20.569c6fea.js"><link rel="prefetch" href="/notes/assets/js/21.5284221e.js"><link rel="prefetch" href="/notes/assets/js/22.f29fe248.js"><link rel="prefetch" href="/notes/assets/js/23.141e596a.js"><link rel="prefetch" href="/notes/assets/js/25.25f9fdd2.js"><link rel="prefetch" href="/notes/assets/js/26.1f6f2ab7.js"><link rel="prefetch" href="/notes/assets/js/27.4e6087a2.js"><link rel="prefetch" href="/notes/assets/js/28.8a49b2e2.js"><link rel="prefetch" href="/notes/assets/js/29.f25e07e2.js"><link rel="prefetch" href="/notes/assets/js/3.02601a78.js"><link rel="prefetch" href="/notes/assets/js/30.c1ec336c.js"><link rel="prefetch" href="/notes/assets/js/31.8f87ea23.js"><link rel="prefetch" href="/notes/assets/js/32.00625d31.js"><link rel="prefetch" href="/notes/assets/js/33.a859abda.js"><link rel="prefetch" href="/notes/assets/js/34.58c894d5.js"><link rel="prefetch" href="/notes/assets/js/35.a667a911.js"><link rel="prefetch" href="/notes/assets/js/36.dec9bb68.js"><link rel="prefetch" href="/notes/assets/js/37.cd9bd3ae.js"><link rel="prefetch" href="/notes/assets/js/38.f2413d3e.js"><link rel="prefetch" href="/notes/assets/js/39.588e60a0.js"><link rel="prefetch" href="/notes/assets/js/4.7a363df4.js"><link rel="prefetch" href="/notes/assets/js/40.e893938e.js"><link rel="prefetch" href="/notes/assets/js/41.2c84b708.js"><link rel="prefetch" href="/notes/assets/js/42.b7d941ae.js"><link rel="prefetch" href="/notes/assets/js/43.d163e3b4.js"><link rel="prefetch" href="/notes/assets/js/44.ac701b61.js"><link rel="prefetch" href="/notes/assets/js/45.1238ac7a.js"><link rel="prefetch" href="/notes/assets/js/46.cae9401c.js"><link rel="prefetch" href="/notes/assets/js/5.720739f0.js"><link rel="prefetch" href="/notes/assets/js/6.5ea91ebd.js"><link rel="prefetch" href="/notes/assets/js/8.b5db7f31.js"><link rel="prefetch" href="/notes/assets/js/9.0c6a1ffe.js"><link rel="prefetch" href="/notes/assets/js/vendors~docsearch.d71392aa.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.29a815fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>nora的笔记本</h3> <p class="description" data-v-59e6cb88>📝记录学习数据</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">nora的笔记本</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      nora的超链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/xtt" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>3</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      nora的超链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/xtt" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/notes/" class="sidebar-heading clickable router-link-active open"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/" aria-current="page" class="sidebar-link">参观前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/notes/notes/computerNetwork" class="sidebar-heading clickable"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/notes/hc.html" class="sidebar-link">Html/Css</a></li><li><a href="/notes/notes/computerNetwork.html" class="sidebar-link">计算机网络</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/notes/notes/vue/basic" class="sidebar-heading clickable open"><span>vue知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/notes/vue/basic.html" class="sidebar-link">基础理念</a></li><li><a href="/notes/notes/vue/develop.html" aria-current="page" class="active sidebar-link">基础开发</a></li><li><a href="/notes/notes/vue/component.html" class="sidebar-link">深入组件</a></li></ul></section></li><li><a href="/notes/notes/react.html" class="sidebar-link">react知识点</a></li><li><a href="/notes/notes/review.html" class="sidebar-link">面试集合点</a></li><li><a href="/notes/notes/answer.html" class="sidebar-link">面试点解析</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title"></h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><p>@[TOC]</p> <h1 id="vue知识记录进度条"><a href="#vue知识记录进度条" class="header-anchor">#</a> vue知识记录进度条 📄</h1> <p><strong>对vue官方文档以及学习过程的记录数据</strong></p> <h2 id="基础开发"><a href="#基础开发" class="header-anchor">#</a> 基础开发</h2> <p><em>目前vue3是开发主流，所以主要以vue3写法为主哦</em></p> <h3 id="响应式基础"><a href="#响应式基础" class="header-anchor">#</a> 响应式基础</h3> <h4 id="ref"><a href="#ref" class="header-anchor">#</a> ref()</h4> <p><strong>使用基础</strong>
ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回;<br>
在模板中使用 ref 时，我们不需要附加 .value,在 JavaScript 中需要 .value;<br> <strong>为什么要使用 ref？</strong>
你可能会好奇：为什么我们需要使用带有 .value 的 ref，而不是普通的变量？这需要说说Vue 的响应式系统是如何工作的了。<a href="#%E5%9F%BA%E7%A1%80%E7%90%86%E5%BF%B5">需要回到基础理念中了</a></p> <h4 id="reactive"><a href="#reactive" class="header-anchor">#</a> reactive()</h4> <p><strong>使用基础</strong>
与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性；
reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> raw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>raw<span class="token punctuation">)</span>
<span class="token comment">// 代理对象和原始对象不是全等的</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy <span class="token operator">===</span> raw<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p><strong>reactive() 的局限性</strong></p> <ol><li>有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型.</li> <li>不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失.</li> <li>对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接;</li></ol> <h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="header-anchor">#</a> Computed 和 Watch 的区别</h3> <h4 id="总结区别"><a href="#总结区别" class="header-anchor">#</a> 总结区别</h4> <ol><li>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</li> <li>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</li> <li>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</li> <li>Computed不支持异步，当Computed中有异步操作时，无法监听数据的变化;Watch支持异步监听</li> <li>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</li> <li>使用场景：当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。
当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li> <li>computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.</li></ol> <h4 id="computed"><a href="#computed" class="header-anchor">#</a> Computed</h4> <p>推荐使用计算属性来描述依赖响应式状态的复杂逻辑,<strong>计算属性值会基于其响应式依赖被缓存</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> publishedBooksMessage <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'Yes'</span> <span class="token operator">:</span> <span class="token string">'No'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>可写计算属性=&gt;计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> firstName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'John'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> lastName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'Doe'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> fullName <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// getter</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> firstName<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName<span class="token punctuation">.</span>value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// setter</span>
  <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 注意：我们这里使用的是解构赋值语法</span>
    <span class="token punctuation">[</span>firstName<span class="token punctuation">.</span>value<span class="token punctuation">,</span> lastName<span class="token punctuation">.</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="watch-函数"><a href="#watch-函数" class="header-anchor">#</a> Watch 函数</h4> <p>为什么有这个watch函数呢？<br>
计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。<br> <strong>使用基础</strong><br>
watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">// 单个 ref</span>
<span class="token function">watch</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newX</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">x is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newX<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// getter 函数</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>value <span class="token operator">+</span> y<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">sum of x + y is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sum<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token comment">// 多个来源组成的数组</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> y<span class="token punctuation">.</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">x is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newX<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and y is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newY<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>⚠️ 注意，你不能直接侦听响应式对象的属性值，这里需要用一个返回该属性的 getter 函数!!!例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 错误方式：因为 watch() 得到的参数是一个 number</span>
<span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 正确方式：提供一个 getter 函数</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token parameter">count</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>深层监听器deep:true</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>someObject<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span>
    <span class="token comment">// *除非* state.someObject 被整个替换了</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">//深层监听 在3.5+中deep 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。</span>
<span class="token punctuation">)</span>
</code></pre></div><div style="border:1px solid #ffc517;margin:28px 0;padding:20px 24px 4px 42px;border-radius:8px;overflow-x:auto;transition:color .5s, background-color .5s;position:relative;font-size:14px;line-height:1.6;font-weight:500;color:#0000008c;background-color:#f9f9f9;"><p class="custom-block-title">谨慎使用</p><p>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p></div>
即时回调的侦听器  
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span>
  source<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 立即执行，且当 `source` 改变时再次执行</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">//还有个一次性监听once：true</span>
<span class="token punctuation">)</span>
</code></pre></div><p>watchEffect():<br> <strong>侦听器的回调使用与源完全相同的响应式状态是很常见的</strong>。<br>
例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> todoId <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  todoId<span class="token punctuation">,</span>
  <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>todoId<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">)</span>
    data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>可以用 watchEffect 函数 来简化上面的代码。watchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>todoId<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">)</span>
  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><em><strong>这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。</strong></em></p><div style="color:orange;">watch vs. watchEffect</div><br>
watch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：<p></p> <ul><li>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li> <li>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li></ul> <h3 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h3> <p>v-show指令的作用是：根据真假值切换元素的显示状态,是响应式的。原理：修改元素的的CSS属性(display)来决定实现显示还是隐藏。值为真(true)的时候元素显示，值为假(false)的时候元素隐藏。数据改变之后呢对应的元素的显示状态也是会同步更新的。<br>
v-if指令的作用：根据表达式的真假切换元素的显示状态 。本质是通过操纵dom元素来进行切换显示。表达式的值为true的时候元素存在于dom树中，为false的时候从dom树中移除.
</p><div style="color:orange;">v-show和v-if的区别</div><p></p> <ol><li>区别</li></ol> <ul><li>v-show指令：元素始终被渲染到HTML，它只是简单的伪元素设置css的style属性，当不满足条件的元素被设置style=“display：none”的样，是通过修改元素的的CSS属性(display)来决定实现显示还是隐藏</li> <li>v-if指令：满足条件是会渲染到html中，不满足条件时是不会渲染到html中的，是通过操纵dom元素来进行切换显示</li></ul> <ol start="2"><li>应用场景</li></ol> <p>v-if需要操作dom元素，有更高的切换消耗，v-show只是修改元素的的CSS属性有更高的初始渲染消耗，如果需要非常频繁的切换，建议使用v-show较好，如果在运行时条件很少改变，则使用v-if较好</p> <h3 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染</h3> <p>我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名。</p> <p>你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.values() 的返回值来决定；</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value in myObject<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ value }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
可以通过提供第二个参数表示属性名 (例如 key)：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(value, key) in myObject<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ key }}: {{ value }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
第三个参数表示位置索引：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(value, key, index) in myObject<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ index }}. {{ key }}: {{ value }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myObject <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'How to do lists in Vue'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">author</span><span class="token operator">:</span> <span class="token string">'Jane Doe'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">publishedAt</span><span class="token operator">:</span> <span class="token string">'2016-04-10'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div style="color:orange;">v-for 与 v-if</div> <p><strong>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名</strong><br> <strong>如何解决？</strong><br>
🚧 在外先包装一层<code>&lt;template&gt;</code>再在其上使用 <code>v-for</code>可以解决这个问题 (这也更加明显易读)
</p><div style="color:orange;">v-for中的key</div><p></p> <ul><li><strong>不写key效率低</strong></li> <li><strong>写key用index会出错，最好用数据唯一标识；不写key会帮你自动生成一个index也会出错</strong> <img src="/notes/assets/img/vFor.050071a8.png" alt="img.png"> <img src="/notes/assets/img/forRes.195caf09.png" alt="img.png"> <img src="/notes/assets/img/v-for.9dc37b7c.png" alt="img.png"></li></ul> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <p><em>此处是vue2作为解释案例</em> <img src="/notes/assets/img/creat.fb39c447.png" alt="img.png"> <img src="/notes/assets/img/end.0851c75e.png" alt="img.png"> <img src="/notes/assets/img/table.b5489a06.png" alt="img.png"></p> <p><em><strong>创建期间的生命周期函数</strong>：</em></p> <p><strong>beforeCreate</strong> 实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性⇒<strong>谁创建之前？数据监测、数据代理创建之前</strong></p> <p><strong>created</strong> 实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始编译模板(模板 比如<code>{{}}</code> ）</p> <p>⇒<strong>created之后vue开始解析模板，生成虚拟dom(内存中)，页面还不能显示解析好的内容</strong></p> <p><em><strong>运行期间的生命周期函数：</strong></em></p> <p><strong>beforeMount</strong> 状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点。页面呈现的是未经vue编译的dom结构，所有的dom的操作，最终都不奏效</p> <p><strong>⇒beforeMount之后将内存中虚拟dom转为真实dom插入页面，并且存了一份到vm.$el</strong></p> <p><strong>mounted</strong> 实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ <strong>Vue完成模板的解析并把初试的真实DOM元素放入页面后（挂载完毕)调用mounted;对dom的操作均有效(但是尽可能避免) 至此初始化过程结束，一般在此进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件，等初始化操作</strong></p> <p><strong>activated</strong></p> <p><strong>deactivated</strong></p> <aside>
💡 要点速记
activated和deactivated是配合keep-alive一起使用的
activated和deactivated没有keep-alive的时候是不会被触发的
在存在keep-alive的时候可以将activated当作created进行使用
deactivated是组件销毁的时候触发，此时的destory是不执行的
</aside> <p><a href="https://blog.csdn.net/qq_41485414/article/details/113698404" target="_blank" rel="noopener noreferrer">113698404<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>beforeUpdate</strong> <strong>数据已经更新了，但是页面还是旧的 数据和页面尚未同步</strong></p> <p><img src="/notes/assets/img/update.5dd1b747.png" alt="img.png"> <strong>updated 数据和页面保持了同步</strong></p> <p><strong>this.$nextTick</strong></p> <p><strong>作用：在下一次dom更新结束后执行其指定的回调</strong></p> <p><strong>什么时候用：当改变数据后，要基于更新后的新dom进行某些操作时，要在nextTick所指定的回调函数中执行</strong></p> <p>$nextTick所指定的回调会在dom节点更新完毕之后再执行！</p> <p><img src="/notes/assets/img/nextick.d6ff9b8b.png" alt="img.png"></p> <p><em><strong>销毁期间的生命周期函数</strong></em>：</p> <p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。此刻，vm中所有的data、methods、指令等等，都处于可用状态，马上要执行销毁过程，一般在此阶段：<strong>关闭定时器啊、取消订阅消息、解绑自定义事件等收尾操作</strong></p> <p><strong>destroyed</strong>  Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <h3 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h3> <h4 id="vue-router-的懒加载如何实现"><a href="#vue-router-的懒加载如何实现" class="header-anchor">#</a> Vue-Router 的懒加载如何实现</h4> <ol><li>非懒加载</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">'@/components/list.vue'</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>方案一(常用)：使用箭头函数+import动态加载</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/list.vue'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>方案二：使用箭头函数+require动态加载</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token punctuation">{</span>
     <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
     <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/list'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="4"><li>方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// r就是resolve
const List = r =&gt; require.ensure([], () =&gt; r(require('@/components/list')), 'list');
// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 
const router = new Router({
  routes: [
  {
    path: '/list',
    component: List,
    name: 'list'
  }
 ]
}))
</code></pre></div><h4 id="路由的hash和history模式的区别"><a href="#路由的hash和history模式的区别" class="header-anchor">#</a> 路由的hash和history模式的区别</h4> <p>Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。</p> <ol><li>hash模式<br> <strong>简介</strong>： <span style="color:orange;">hash模式是开发中默认的模式，它的URL带着一个#</span>，例如<code>www.abc.com/#/vue</code>，它的hash值就是#/vue。<br> <strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。
<strong>原理</strong>： hash模式的主要原理就是onhashchange()事件：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。<br>
2. history模式<br> <strong>简介</strong>： <span style="color:orange;">history模式的URL中没有#，它使用的是传统的路由分发模式</span>，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。<br> <strong>特点</strong>： 当使用history模式时，URL就像这样：abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。<br> <strong>API</strong>： history api可以分为两大部分，切换历史状态和修改历史状态：</p> <ul><li>修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li> <li>切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</li></ul> <ol start="3"><li>两种模式对比<br>
调用 history.pushState() 相比于直接修改 hash，存在以下优势:</li></ol> <ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li> <li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li> <li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li> <li>pushState() 可额外设置 title 属性供后续使用。</li> <li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul> <h4 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="header-anchor">#</a> $route 和$router 的区别</h4> <ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li> <li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul> <h4 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫</h4> <h5 id="全局路由守卫"><a href="#全局路由守卫" class="header-anchor">#</a> 全局路由守卫</h5> <ol><li>全局前置路由守卫<br>
应用：有要求的看某些组件⇒例如用户权限</li></ol> <div class="language- extra-class"><pre class="language-text"><code>router.beforeEach((to,from,next)=&gt;{
		//	next()//所有的都被拦截，写next放行
if(to.path==='/home/news'||to.path==='/home/message'){
		if(localStorage.getItem('school)==='bufan'){
    next()
		}
}else{
		alert('学校名不对，无权限查看！')
}
})
</code></pre></div><p><strong>但是有很多组件页面需要权限判断呢？</strong> 这时候需要每个路由配置就需要<code>meta</code>(路由元信息)</p> <div class="language- extra-class"><pre class="language-text"><code>{
	name:'xinwen',
	path:'news',
	component:News,
	meta:{isAuth:true，title:'新闻'}
},
{
	name:'xiaoxi',
	path:'message',
	component:Message,
	meta:{isAuth:true},
	children:[
		{
			name:'xiangqing',
			path:'detail',
			component:'Detail'
		}
	]
}
router.beforeEach((to,from,next)=&gt;{
if(to.meta.isAuth){//判断是否需要鉴权  //这样就不用在这里写那么多组件名或者路径了，在router配置里就直接挑出你需要给权限的就行了
		if(localStorage.getItem('school)==='bufan'){
    next()
		}
}else{
		alert('学校名不对，无权限查看！')
}else{
		next()
}

})
</code></pre></div><ol start="2"><li>全局后置路由守卫(作用)</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//-初始化的时候调用，每一次路由器切换之后都调用一个函数=&gt;全局后置路由守卫</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
document<span class="token punctuation">.</span>title <span class="token operator">=</span> to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>title<span class="token operator">||</span><span class="token string">'管理系统'</span> <span class="token comment">//写这里是最保险的！这样</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><em>为什么写这里？，如果可以走这里就意味着切换肯定切完了，切换完了你再改一下名字意味着所有的在beforeEach中的业务都做完了，你再改一下名字，这样是最保险的</em></p> <h5 id="独享路由守卫-只有前置没有后置"><a href="#独享路由守卫-只有前置没有后置" class="header-anchor">#</a> 独享路由守卫(只有前置没有后置)</h5> <p><img src="/notes/assets/img/beforeEnter.bf6f24e8.png" alt="img.png"></p> <h5 id="组件内路由守卫"><a href="#组件内路由守卫" class="header-anchor">#</a> 组件内路由守卫</h5> <p><em>全局路由守卫你切换了他就会在你切换的时候全局前置和全局后置都给你相继调用了，但是组件内的路由守卫是你从home到about在君如这个about组件之前调用beforeRouteEnter但是调用完了并没有相继的调用beforeRouteLeave，这个是当你确定离开这个组件去另一个组件的时候调用的</em></p> <div class="language- extra-class"><pre class="language-text"><code>通过路由规则，进入该组件时被调用
beforeRouteEnter(to,from.next){
逻辑是这个组件独有的，也可以单独给这个组件鉴权的
		 if(to.meta.isAuth){//判断是否需要鉴权
		      if(localStorage.getItem('school)==='bufan'){
             next()
		        }
        }else{
		        alert('学校名不对，无权限查看！')
         }else{
						next()
				 }

}
通过路由规则，离开该组件时调用
beforeRouteLeave(to,from,next) {
}
</code></pre></div><p><img src="/notes/assets/img/beforeRouteLeave.b7ffd540.png" alt="img.png"></p> <blockquote><p><strong>完整的导航解析流程</strong></p> <ol><li>导航被触发。</li> <li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li> <li>调用全局的 <code>beforeEach</code> 守卫。</li> <li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li> <li>在路由配置里调用 <code>beforeEnter</code>。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li> <li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 <code>afterEach</code> 钩子。</li> <li>触发 DOM 更新。</li> <li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol></blockquote></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/notes/notes/vue/basic.html" class="prev">
          基础理念
        </a></span> <span class="next"><a href="/notes/notes/vue/component.html">
          深入组件
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#基础开发" class="sidebar-link reco-side-基础开发" data-v-b57cc07c>基础开发</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#响应式基础" class="sidebar-link reco-side-响应式基础" data-v-b57cc07c>响应式基础</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#computed-和-watch-的区别" class="sidebar-link reco-side-computed-和-watch-的区别" data-v-b57cc07c>Computed 和 Watch 的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#条件渲染" class="sidebar-link reco-side-条件渲染" data-v-b57cc07c>条件渲染</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#列表渲染" class="sidebar-link reco-side-列表渲染" data-v-b57cc07c>列表渲染</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#生命周期" class="sidebar-link reco-side-生命周期" data-v-b57cc07c>生命周期</a></li><li class="level-3" data-v-b57cc07c><a href="/notes/notes/vue/develop.html#路由" class="sidebar-link reco-side-路由" data-v-b57cc07c>路由</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/notes/assets/js/app.a7b0928b.js" defer></script><script src="/notes/assets/js/7.d12e4840.js" defer></script><script src="/notes/assets/js/2.dfe3d436.js" defer></script><script src="/notes/assets/js/1.102225a7.js" defer></script><script src="/notes/assets/js/24.44ecaef9.js" defer></script>
  </body>
</html>
